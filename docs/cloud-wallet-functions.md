# CLoud Wallet and Enterprise Server API Endpoint and Function Guide

This is a guide to all of the functions in the vcx-enterprise-server.js Node Express Server, which are set up to receive connection requests with an invitiation, receive and accept credential offers, and to receive and answer proof requests. These are the Wallet Holder functions that are most prominent in the mobile SDK, where the Connect.Me mobile wallet software is intended to use. The primary model in the Evernym code stack is based upon an Enterprise Issuer to Consumer Holder flow, which predicates that the Mobile App user will accept connections, accept credential offers, and accept and respond to Proof Requests with a proof object. 


## Basic Architecture

This Cloud Wallet example is set up to act as a Cloud-based Connect.Me implementation. The purpose is to have an automated service to accept credentials and proofs on behalf of the Holder, whether that Holder is an enterprise or individual. This implementation uses a Node Express Server to process API endpoint requests, which will initiate the process of waiting for the request to come in. The API server request path initiates the functions that will listen to the Enterprise Agency Service for connections, credentials, and proofs. The sequence for a typical request process flow is as follows:

1. Endpoint /api/v1/receive_credentials is accessed by the requesting entity with the request body of the connection invitation (generated by the VCX Server). This calls connectionWithInvite.
2. Connection Invitation is sent to the API endpoint and Cloud Wallet server accepts the invitation, generating a Connection.
3. Credential.getOffers(connection) is run, a function which begins to listen for credential offers passing through the Enterprise Agency Server. This runs on a loop until a credential offer is detected, at which point a Credential is created and requested from the EAS.


4. A Credential Offer is sent to the created connection (this passes through the Enterprise Agency Server )

## Accepting a Connection Invite

Accepting a Connection invitation


## Receiving and Accepting a Credential Offer: /api/v1/receive_credentials 

This creates the connection with an invitation and begins the process of listening for the credential offers from a specific connection. A connection is created via the invite details that are sent through the POST request (which have been pre-generated from the server). Once the conneciton has been established on the Holder end, the instance of Libvcx will begin to "listen" for credential offers from the connection in question, which will come through from the Enterprise Agency Service. Once a credential offer comes through, that offer will be converted into a credential and a request for that credential will be passed through to the Enterprise Server. This is the equivalent of a credential offer being accepted in the mobile app and issued from the Enterprise server to the Holder.

```javascript

  let inviter = req.body['s']['n'];// this is from the connection data, containing the source_id of the connection 
  let inviteDetails = JSON.stringify(req.body);// these are the invitation details, sent with the API POST request
  let connection = await vcxwebtools.connectWithInvitation('1', inviteDetails);// this creates a connection from the invite details
  await connection.connect({id:"1"});// this accepts the connection created with the following line
  console.log('Connection Invite Accepted');
  await connection.updateState();
  let state = await connection.getState();
  while(state != StateType.Accepted){// this loop sends the state back to the Enterprise Agency Service as an accepted Connection
      await connection.updateState();
      state = await connection.getState();
      console.log("State is :::");
      console.log(state);
  }
  let offers = await Credential.getOffers(connection);// this will get all offers from a specific connection
  while(offers.length < 1){// loop to wait for credential offers
      offers = await Credential.getOffers(connection);// updates the offer list from the Enterprise Agency Server
      console.log("Credential Offers Below:");
      console.log(JSON.stringify(offers[0]));// logs the top offer
  }
  let credential = await Credential.create({ sourceId: 'enterprise', offer: JSON.stringify(offers[0]), connection: connection});// Creates a credential from the credential offer
  await credential.sendRequest({ connection: connection, payment: 0});// sends the request to the Enterprise Agency Server for the offered credential. This is the same as credential offer request accepted state on the server-side.
```


## Accepting and responding to a Proof Request: /api/v1/receive_proof_request

 A Proof Request flow on the Holder side is much like the Credential Offer. A Connection with Invitation is created (see below for reconnecting to an existing connection) and the Proof Request is sent to that Connection through the Enterprise Agency Service. The POST request will initiate the Connection process and also prompt the server to listen for the proof requests from the Connection in question. Once the Proof Request is received, if a Proof Object can be generated with the parameters and restrictions of the Proof Request, it will be automatically created and sent back to the Requester.

 ```javascript
  app.post(`/api/v1/receive_proof_request`, async function(req,res){
      let inviteDetails = JSON.stringify(req.body);// connection invitations
      let nm = req.body['s']['n'];// name of connection
      // Accept invitation
      let connection= await Connection.createWithInvite({ id: '1', invite: inviteDetails });// accepts the connection from the invitation
      await connection.connect({id:"1"});// generates the keys and stores the connection into the wallet
      console.log('Connection Invite Accepted');
      await connection.updateState();
      let state = await connection.getState();
      while(state != StateType.Accepted){// poll for the Enterprise Agency Server to report back an Accepted State
          sleep(5000);
          await connection.updateState();
          state = await connection.getState();
      }
      let ser_connection = await connection.serialize();
      let requests = await DisclosedProof.getRequests(connection);// this will get all Proof Requests from the Enterprise Agency Server for this particular connection
      while(requests.length == 0){
          sleep(5000);
          requests = await DisclosedProof.getRequests(connection);// once the proof request is found, it will populate the requests var
          console.log("Waiting on Requests");
      }
      console.log('Creating a Disclosed proof object from proof request');
      let proof = await DisclosedProof.create({ sourceId: 'proof', request: JSON.stringify(requests[0])});// create a Proof Request from the request
      console.log(await proof.serialize());
      console.log('Query for credentials in the wallet that satisfy the proof request');
      let credentials = await proof.getCredentials();// looks into the wallet for credentials that match restrictions in the Proof Request
      console.log(credentials);
      let self_attested;
      for (let attr in credentials['attrs']) {// this loop lists all self_attested credentials in the proof object credentials as returned by proof.getCredentials()
          credentials['attrs'][attr] = { credential: credentials['attrs'][attr][0] };
          console.log(attr);
          self_attested = attr;
      }
      // if the proof request matches the credential in the wallet
      let cred_x = JSON.stringify(credentials['attrs'][self_attested]);
      console.log(`LENGTH OF CREDS IS ${cred_x}`);
      console.log(credentials['attrs']);
      console.log('Generate the proof');
      if(cred_x != '{}'){
          console.log("The credential exists");
          await proof.generateProof({selectedCreds: credentials, selfAttestedAttrs: {}});
      }else{
          console.log("Credential does not exist");
          credentials = { self_attested: { credential: "undefined" } };
          await proof.generateProof({selectedCreds: credentials, selfAttestedAttrs: {}});
      }
      let s_proof = await proof.serialize();
      console.log(s_proof);
      console.log('Send the proof to agent');
      await proof.sendProof(connection);// sends the proof object to the Proof Requester
      await proof.updateState();
      let pstate = await proof.getState();
      while(pstate !== 4){// waits for the proof to be sent back and the State=4
          sleep(2000);
          console.log(`proof should have been sent  the State is : ${pstate}`);
          await proof.updateState();
          pstate = proof.getState();
      }
      console.log(`Proof sent!!`);
  })
 ```

## Connection Redirects and recognizing Connections from requests

There are two scenarios that would work with the CLoud Wallet architecture:

1. **New Connection is made with each transaction** - the easiest to manage from a code perspective, but this is very inefficient and not suggested proper practice. In the case of anonymous or non-public connections, this is the suggested method.
2. **Connection Redirect** - if an incoming connection invitation matches a connection that already exists from the inviting party (enterprise server), the connection can then be redirected to the existing connection. This means that the invitation reaches the Cloud Wallet, the state of "redirect (8)" is sent back to the Inviting party, at which point the connection from the server *must* be retrieved from saved storage data. Connection redirect requires that the Enterprise server stores the connection data in a database of some kind.